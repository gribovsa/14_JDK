### Урок 5. Многопоточность
Есть пять философов (потоки), которые могут либо обедать, либо размышлять (ожидание).
Каждый философ должен пообедать три раза. Каждый прием пищи длиться 500 миллисекунд
После каждого приема пищи философ должен размышлять.
Не должно возникнуть общей блокировки.
Философы не должны есть больше одного раза подряд.

### Описание кода

Cоздается пять философов (потоков) и один стол (семафор), который ограничивает доступ к столу четырех философов. 
Это сделано для предотвращения взаимной блокировки (deadlock). 
Философы будут пытаться сесть за стол и пообедать, и если стол занят четырьмя философами, 
пятому будет отказано в доступе, и он будет продолжать размышлять.

`Philosopher` - класс, представляющий философа. Каждый философ реализует интерфейс Runnable, 
что позволяет его использовать как поток.

В методе `run()`, который реализует интерфейс `Runnable`, философ выполняет следующие действия:

- Размышляет, вызывая метод `think()`.
- Затем пытается захватить стол, вызывая `table.acquire()`. Если стол уже занят четырьмя философами, 
  этот вызов будет заблокирован до тех пор, пока стол не станет доступным.
- После успешного захвата стола, философ обедает, вызывая `eat()`.
- Затем он освобождает стол, вызывая `table.release()`, чтобы другие философы могли его использовать.


#### Философы будут чередовать между размышлением и обедом, соблюдая правила и избегая блокировок при помощи семафора.